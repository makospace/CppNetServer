1. 底层使用 Epoll + LT 模式的 I/O 复用模型，并且结合非阻塞 I/O 实现主从 Reactor 模型。
2. 采用「one loop per thread」线程模型，并向上封装线程池避免线程创建和销毁带来的性能开销。
3. 采用 eventfd 作为事件通知描述符，方便高效派发事件到其他线程执行异步任务。
4. 基于自实现的双缓冲区实现异步日志，由后端线程负责定时向磁盘写入前端日志信息，避免数据落盘时阻塞网络服务。
5. 基于红黑树实现定时器管理结构，内部使用 Linux 的 timerfd 通知到期任务，高效管理定时任务。 
6. 利用有限状态机解析 HTTP 请求报文。
7. 想着为了轻量级的目标，正在准备实现了内存池模块，以便于更好管理小块内存空间，减少内存碎片，可以遵循 RALL 手法使用智能指针管理内存，减小内存泄露风险。
8. 想着可以记录每个用户的特点进行配置设置，可以用数据库来实现，可以使用数据库连接池可以动态管理连接数量，及时生成或销毁连接，保证连接池性能。

### 主要类介绍：
1. EventLoop类：事件循环类，负责维护事件循环，处理IO事件、定时器事件和信号事件等。

2. Channel类：通道类，封装了一个文件描述符（socket或者文件），负责处理该文件描述符上的IO事件。

3. TcpConnection类：TCP连接类，封装了一个TCP连接，负责处理该连接上的IO事件和状态管理。

4. TcpServer类：TCP服务器类，负责监听和管理TCP连接，包括接受新连接、关闭连接等操作。

5. Buffer类：缓冲区类，封装了一个可变长度的字节数组，提供了读写操作和数据处理的接口。

6. TimerQueue类：定时器队列类，负责管理定时器事件，包括添加、删除、触发等操作。

7. Log类：日志类，提供了日志记录和输出的接口，支持多线程输出和异步日志。

8. Thread类：线程类，封装了一个线程对象，提供了线程的创建、启动、停止等操作。

9. ThreadPool类：线程池类，负责管理线程池，包括添加任务、线程池扩容等操作。

10. 该项目是一个C++实现的网络服务器，可以同时处理多个连接。它由几个类组成，每个类负责服务器功能的特定方面。
11. EventLoop类是服务器的核心，负责管理所有I/O事件。它使用epoll系统调用来有效地监视多个文件描述符的事件。
12. Channel类用于表示由事件循环监视的文件描述符。它提供了启用/禁用读写事件的方法，以及在发生事件时调用的回调函数
13. Socket类用于创建和操作套接字。它提供了创建、绑定、监听、接受和连接套接字的方法。
14. Acceptor类负责在指定的IP地址和端口号上接受传入的连接。它创建一个Socket对象，并将其绑定到IP地址和端口号上。然后，它使用套接字的文件描述符和传递的事件循环创建一个Channel对象。当套接字准备好读取时，设置回调函数AcceptConnection()将被调用。当接受新连接时，将调用AcceptConnection()。它首先检查套接字对象的Accept()方法是否返回RC_SUCCESS。如果是，则使用fcntl()将新连接的文件描述符设置为非阻塞模式。最后，如果设置了新连接回调函数，则将其调用，并将新连接的文件描述符作为参数传递。
15. Connection类表示与客户端的连接。它使用传递的文件描述符创建一个Socket对象。然后，它使用套接字的文件描述符和传递的事件循环创建一个Channel对象。当套接字准备好读取时，设置回调函数HandleRead()将被调用。当有数据可读时，将调用HandleRead()。它将数据读入缓冲区，并调用用户定义的回调函数，将数据作为参数传递。
16. Buffer类用于表示数据缓冲区。它提供了读取和写入数据到/从缓冲区的方法。总的来说，该项目提供了一个框架，用于构建可以同时处理多个连接的网络服务器。
### 采用的模式：Reactor模式
还有一些其他模式：
1. Proactor模式：与Reactor模式类似，但是在处理I/O操作时采用了异步的方式，即I/O操作完成后再通知应用程序。
2. Actor模式：将系统中的每个组件都看作是一个独立的Actor，通过消息传递来实现组件之间的通信和协作。
3. Half-sync/Half-async模式：将应用程序分为两部分，一部分异步处理I/O事件，另一部分同步处理业务逻辑。
4. Thread-pool模式：将一组线程预先创建好，当有任务到来时将任务分配给线程池中的线程来处理，避免了线程的频繁创建和销毁。
Reactor模式的特点：
1. 采用事件驱动的方式处理I/O操作，提高了系统的可伸缩性和性能。
2. 将I/O操作和业务逻辑分离，使得系统的设计更加清晰和易于维护。
3. 通过回调函数的方式来处理I/O事件的结果，避免了阻塞操作，提高了系统的并发性。
4. 可以通过选择合适的设计模式来扩展Reactor模式，使得系统更加灵活和可扩展。
5. 事件驱动的IO和异步IO都是实现高效IO操作的方法，但是有一些异同点。
>事件驱动的IO是指程序通过监听事件来实现IO操作，当有事件发生时，程序才会进行相应的IO操作。常见的事件驱动模型包括Reactor模型和Proactor模型。异步IO是指程序在进行IO操作时，不需要等待IO操作完成，而是可以继续执行其他操作。异步IO通常需要使用回调函数来处理IO操作的结果。区别在于，事件驱动的IO是通过监听事件来实现IO操作，而异步IO是通过不等待IO操作完成来实现高效IO操作。事件驱动的IO通常需要使用事件循环来处理事件，而异步IO则需要使用回调函数来处理IO操作的结果。

*智能指针*：
>1. 普通指针：普通指针是C++中最基本的指针类型，它只是一个指向内存地址的变量，不具有自动内存管理的功能。需要手动分配和释放内存，容易出现内存泄漏和悬挂指针等问题。
>2. unique_ptr：unique_ptr是C++11引入的一种智能指针，它是一种独占式的智能指针，即一个unique_ptr对象只能有一个指向同一个对象的指针，不能进行复制或赋值。当unique_ptr超出作用域或被删除时，它所指向的对象也会被自动释放。unique_ptr实现原理是通过模板类和move语义实现的。
>3. shared_ptr：shared_ptr也是C++11引入的智能指针，它是一种共享式的智能指针，多个shared_ptr对象可以指向同一个对象，对象的引用计数会增加，只有当最后一个shared_ptr对象被销毁时，对象才会被释放。shared_ptr实现原理是通过引用计数实现的。
>4. weak_ptr：weak_ptr也是C++11引入的智能指针，它是一种弱引用的智能指针，它可以指向一个由shared_ptr管理的对象，但不会增加对象的引用计数，当最后一个shared_ptr被销毁后，weak_ptr也会自动失效。weak_ptr实现原理是通过一个弱引用计数器实现的。

特点：
>1. unique_ptr具有独占式的特点，能够防止多个指针同时访问同一个对象，从而避免了悬挂指针和内存泄漏等问题。
>2. shared_ptr可以实现多个指针共享同一个对象，可以避免内存泄漏和悬挂指针等问题。
>3. weak_ptr可以用于解决shared_ptr的循环引用问题，避免内存泄漏。
>4. 普通指针没有自动内存管理的功能，需要手动分配和释放内存，容易出现内存泄漏和悬挂指针等问题。

悬挂指针：指向已经被释放空间的指针

shared_ptr的循环引用：如果存在循环引用，即两个或多个对象相互持有对方的shared_ptr，那么它们都无法被释放，因为它们的引用计数永远不会变为0。这时候，可以将其中一个shared_ptr改为weak_ptr，这样它不会增加对象的引用计数

### 如何使用CMake：
CMake是一个跨平台的开源构建工具，可以帮助开发人员管理和构建项目。以下是使用CMake构建项目的步骤：

1. 创建一个源代码目录，包含项目的所有源文件和头文件。

2. 在源代码目录中创建一个CMakeLists.txt文件，该文件包含构建项目所需的所有指令和配置。

3. 在CMakeLists.txt文件中指定项目名称和版本号：

```
project(MyProject VERSION 1.0.0)
```

4. 指定要编译的源文件和头文件：

```
add_executable(MyProject main.cpp foo.cpp bar.cpp)
```

5. 添加所需的库或依赖项：

```
find_package(Boost REQUIRED)
target_link_libraries(MyProject Boost::boost)
```

6. 指定编译选项和标志：

```
set(CMAKE_CXX_FLAGS "-Wall -Wextra")
```

7. 指定构建目录：

```
set(CMAKE_BINARY_DIR ${CMAKE_SOURCE_DIR}/build)
```

8. 在构建目录中运行CMake：

```
cd build
cmake ..
```

9. 编译项目：

```
make
```

10. 运行项目：

```
./MyProject
```

以上是使用CMake构建项目的基本步骤，可以根据项目需求进行调整和修改
CMake根据CMakeLists.txt生成不同平台下的Makefile文件，make根据Makefile文件编译连接代码

GCC是GUN的编译工具集，可以编译多种语言，gcc是c++的编译器（一般用大小写区分）
https://blog.csdn.net/weixin_46272577/article/details/128295509

https://github.com/Shangyizhou/A-Tiny-Network-Library/blob/main/%E9%A1%B9%E7%9B%AE%E8%AE%B2%E8%A7%A3/
